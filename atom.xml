<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>若 叶</title>
  
  
  <link href="https://wangyinfeng123.github.io/atom.xml" rel="self"/>
  
  <link href="https://wangyinfeng123.github.io/"/>
  <updated>2020-09-01T08:43:05.029Z</updated>
  <id>https://wangyinfeng123.github.io/</id>
  
  <author>
    <name>若叶</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>gdb调试基础</title>
    <link href="https://wangyinfeng123.github.io/2020/09/01/gdb%E8%B0%83%E8%AF%95%E5%9F%BA%E7%A1%80/"/>
    <id>https://wangyinfeng123.github.io/2020/09/01/gdb%E8%B0%83%E8%AF%95%E5%9F%BA%E7%A1%80/</id>
    <published>2020-09-01T08:19:48.000Z</published>
    <updated>2020-09-01T08:43:05.029Z</updated>
    
    <content type="html"><![CDATA[<p>gdb调试基础知识和常用的基本指令。</p><a id="more"></a><p><strong>编译时加入可调试选项，启动服务器进入调试：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//编译时应加入可调试选项 -g；</span><br><span class="line">g++ -std=c++11 testthread.cpp -o testthread -lpthread -g</span><br><span class="line">//调用gdb命令进入调试界面</span><br><span class="line">gdb testthread</span><br></pre></td></tr></table></figure><p>也可以先运行一个线程，再通过 ps -ef | grep 找到进程的PID，然后通过attach将进程附加到gdb调试器上</p><blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">./server -c 1000 -t 20</span><br><span class="line">//另开端口查看PID</span><br><span class="line">ps -ef | grep server</span><br><span class="line">gdb attach [PID_num]</span><br><span class="line"></span><br><span class="line">oot@iZ2zed3d8a5mhbo5gb2m7rZ:~/webbench-1.5# gdb attach 18445</span><br><span class="line">GNU gdb (Ubuntu 7.11.1-0ubuntu1~16.5) 7.11.1</span><br><span class="line">Copyright (C) 2016 Free Software Foundation, Inc.</span><br><span class="line">License GPLv3+: GNU GPL version 3 or later &lt;http://gnu.org/licenses/gpl.html&gt;</span><br><span class="line">This is free software: you are free to change and redistribute it.</span><br><span class="line">There is NO WARRANTY, to the extent permitted by law.  Type &quot;show copying&quot;</span><br><span class="line">and &quot;show warranty&quot; for details.</span><br><span class="line">This GDB was configured as &quot;x86_64-linux-gnu&quot;.</span><br><span class="line">Type &quot;show configuration&quot; for configuration details.</span><br><span class="line">For bug reporting instructions, please see:</span><br><span class="line">&lt;http://www.gnu.org/software/gdb/bugs/&gt;.</span><br><span class="line">Find the GDB manual and other documentation resources online at:</span><br><span class="line">&lt;http://www.gnu.org/software/gdb/documentation/&gt;.</span><br><span class="line">For help, type &quot;help&quot;.</span><br><span class="line">Type &quot;apropos word&quot; to search for commands related to &quot;word&quot;...</span><br><span class="line">attach: No such file or directory.</span><br><span class="line">Attaching to process 18445</span><br><span class="line">[New LWP 18448]</span><br><span class="line">[New LWP 18449]</span><br><span class="line">[New LWP 18450]</span><br><span class="line">[New LWP 18451]</span><br><span class="line">[New LWP 18452]</span><br><span class="line">[New LWP 18453]</span><br><span class="line">[New LWP 18454]</span><br><span class="line">[New LWP 18455]</span><br><span class="line">[New LWP 18456]</span><br><span class="line">[New LWP 18457]</span><br><span class="line">[Thread debugging using libthread_db enabled]</span><br><span class="line">Using host libthread_db library &quot;/lib/x86_64-linux-gnu/libthread_db.so.1&quot;.</span><br><span class="line">0x00007f9ef4fb0a13 in epoll_wait () at ../sysdeps/unix/syscall-template.S:84</span><br><span class="line">84    ../sysdeps/unix/syscall-template.S: No such file or directory.</span><br><span class="line"></span><br></pre></td></tr></table></figure></blockquote><ul><li>定位查看行号，打断点b， 查看断点信息</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//在指定文件指定行打断点</span><br><span class="line">(gdb) b threadpool.h:39</span><br><span class="line">Breakpoint 1 at 0x40d076: file ./threadpool/threadpool.h, line 39.</span><br><span class="line">(gdb) i b</span><br><span class="line">Num     Type           Disp Enb Address            What</span><br><span class="line">1       breakpoint     keep y   0x000000000040d076 in threadpool&lt;http_conn&gt;::threadpool(int, connection_pool*, int, int) at ./threadpool/threadpool.h:39</span><br></pre></td></tr></table></figure><p>或者先查看文件行号信息，再确定打断点的位置</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">(gdb) l testthread.cpp:17</span><br><span class="line">12    </span><br><span class="line">13    void func(int num)&#123;</span><br><span class="line">14        while(true)&#123;</span><br><span class="line">15            sleep(1);</span><br><span class="line">16        lock_guard&lt;mutex&gt;lock(_mutex);</span><br><span class="line">17        total += num;</span><br><span class="line">18        cout &lt;&lt; &quot;num:&quot; &lt;&lt; num &lt;&lt; endl; </span><br><span class="line">19        &#125;</span><br><span class="line">20    &#125;</span><br><span class="line">21    </span><br><span class="line">(gdb) b 17</span><br><span class="line">Breakpoint 1 at 0x40118c: file testthread.cpp, line 17.</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>运行程序</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//run</span><br><span class="line">(gdb) run </span><br><span class="line">//cintinue</span><br><span class="line">(gdb) c</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(gdb) run</span><br><span class="line">Starting program: /root/tets/testthread </span><br><span class="line">[Thread debugging using libthread_db enabled]</span><br><span class="line">Using host libthread_db library &quot;/lib/x86_64-linux-gnu/libthread_db.so.1&quot;.</span><br><span class="line">[New Thread 0x7ffff6f4e700 (LWP 14859)]</span><br><span class="line">[New Thread 0x7ffff674d700 (LWP 14860)]</span><br><span class="line">[Switching to Thread 0x7ffff6f4e700 (LWP 14859)]</span><br></pre></td></tr></table></figure><pre><code>显示当前可调试的所有线程，gdb会为所线程编号分配一个ID，可以根据这个ID切换线程，‘*’表示当前正在调试的线程。</code></pre><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(gdb) info threads</span><br><span class="line">  Id   Target Id         Frame</span><br><span class="line">  1    Thread 0x7ffff7fe3740 (LWP 15191) &quot;testthread&quot; 0x00007ffff7bc298d in pthread_join (threadid=140737336633088, thread_return=0x0) at pthread_join.c:90</span><br><span class="line">* 2    Thread 0x7ffff6f4e700 (LWP 15195) &quot;testthread&quot; fun (num=3) at testthread.cpp:17</span><br><span class="line">  3    Thread 0x7ffff674d700 (LWP 15196) &quot;testthread&quot; fun (num=5) at testthread.cpp:17</span><br><span class="line">(gdb)</span><br></pre></td></tr></table></figure><ul><li>调试目标ID指定的线程</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//thread [ID]</span><br><span class="line">(gdb) thread 1</span><br><span class="line">[Switching to thread 1 (Thread 0x7ffff7feb740 (LWP 14855))]</span><br><span class="line"><span class="meta">#</span><span class="bash">0  0x00007ffff7bc298d <span class="keyword">in</span> pthread_join (threadid=140737336633088, thread_return=0x0) at pthread_join.c:90</span></span><br><span class="line">90    pthread_join.c: No such file or directory.</span><br></pre></td></tr></table></figure><ul><li>执行下一步</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// next</span><br><span class="line">n</span><br></pre></td></tr></table></figure><ul><li>选择调试父进程或者子进程，通过设置follow-fork-mode parent/child 选择。</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//选项设置parent则调试父进程，反之则子进程</span><br><span class="line">(gdb) set follow-fork-mode [parent/child]</span><br></pre></td></tr></table></figure><ul><li>只让被调试线程运行。调试多线程时，除了当前被调试的线程，其他线程默认也在继续运行，设置schdular-locking 可以只让被调试的线程运行，off表示不锁定任何线程，即所有线程都可以运行，on表示只有当前线程运行，step表示单步执行时只有当前线程运行。</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">(gdb) set scheduler-locking on</span><br><span class="line">(gdb) n</span><br><span class="line">do_futex_wait (sem=sem@entry=0x1d2dae0, abstime=0x0) at sem_waitcommon.c:111</span><br><span class="line">111    sem_waitcommon.c: No such file or directory.</span><br><span class="line">(gdb) n</span><br><span class="line">120    in sem_waitcommon.c</span><br><span class="line">(gdb) n</span><br><span class="line">__new_sem_wait_slow (sem=0x1d2dae0, abstime=0x0) at sem_waitcommon.c:191</span><br><span class="line">191    in sem_waitcommon.c</span><br></pre></td></tr></table></figure><ul><li>显示子线程的调用栈bt</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">(gdb) bt</span><br><span class="line"><span class="meta">#</span><span class="bash">0  __new_sem_wait_slow (sem=0x1d2dae0, abstime=0x0) at sem_waitcommon.c:191</span></span><br><span class="line"><span class="meta">#</span><span class="bash">1  0x00007f9ef5dd197a <span class="keyword">in</span> __new_sem_wait (sem=&lt;optimized out&gt;) at sem_wait.c:29</span></span><br><span class="line"><span class="meta">#</span><span class="bash">2  0x000000000040ab68 <span class="keyword">in</span> sem::<span class="built_in">wait</span> (this=0x1d2dae0) at CGImysql/../lock/locker.h:31</span></span><br><span class="line"><span class="meta">#</span><span class="bash">3  0x000000000040d5e6 <span class="keyword">in</span> threadpool&lt;http_conn&gt;::run (this=0x1d2da90) at ./threadpool/threadpool.h:104</span></span><br><span class="line"><span class="meta">#</span><span class="bash">4  0x000000000040d44a <span class="keyword">in</span> threadpool&lt;http_conn&gt;::worker (arg=0x1d2da90) at ./threadpool/threadpool.h:96</span></span><br><span class="line"><span class="meta">#</span><span class="bash">5  0x00007f9ef5dc96ba <span class="keyword">in</span> start_thread (arg=0x7f9ee3e3e700) at pthread_create.c:333</span></span><br><span class="line"><span class="meta">#</span><span class="bash">6  0x00007f9ef4fb041d <span class="keyword">in</span> <span class="built_in">clone</span> () at ../sysdeps/unix/sysv/linux/x86_64/clone.S:109</span></span><br></pre></td></tr></table></figure><ul><li>推出调试状态</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) q</span><br></pre></td></tr></table></figure><p>实际调试多进程或者多线程时，可以先将进程池或者线程池的数量设为1，观察程序逻辑是否正常，然后逐渐增加数量，调试程序是否正确。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;gdb调试基础知识和常用的基本指令。&lt;/p&gt;</summary>
    
    
    
    <category term="Linux" scheme="https://wangyinfeng123.github.io/categories/Linux/"/>
    
    
  </entry>
  
  <entry>
    <title>Linux网络编程常用指令</title>
    <link href="https://wangyinfeng123.github.io/2020/08/20/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/"/>
    <id>https://wangyinfeng123.github.io/2020/08/20/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/</id>
    <published>2020-08-20T03:34:12.000Z</published>
    <updated>2020-09-01T07:45:16.619Z</updated>
    
    <content type="html"><![CDATA[<p>总结常用的Linux网络编程命令，助力调试和网络系统信息查看。</p><a id="more"></a><h3 id="daemon"><a href="#daemon" class="headerlink" title="daemon"></a><strong>daemon</strong></h3><p>注册守护进程 。将一个进程注册为守护进程可以在后台运行，脱离当前终端的限制，具体流程是：先fork一个子进程，然后关闭对应的父进程，设置文件权限掩码，再调用setsid()创建一个新的会话，同时设置本进程为进程组的首领，切换工作目录以后关闭标准输入输出和错误，将标准输入输出错误重定向到/dev/null文件。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">bool daemon()&#123;</span><br><span class="line">    pid_t pid = fork();</span><br><span class="line">    assert(pid &gt;= 0);</span><br><span class="line">    if(pid &gt; 0)</span><br><span class="line">        exit(0);</span><br><span class="line">    umask(0);</span><br><span class="line">    pid_t sid = setsid();</span><br><span class="line">    assert(sid &gt;= 0);</span><br><span class="line">    assert(chdir(&quot;/&quot;) &gt;= 0);</span><br><span class="line">    close(STDIN_FILENO);</span><br><span class="line">    close(STDOUT_FILENO);</span><br><span class="line">    close(STDERR_FILENO);</span><br><span class="line">    open(&quot;/dev/null&quot;, O_RDONLY);</span><br><span class="line">    open(&quot;/dev/null&quot;, O_RDWR);</span><br><span class="line">    open(&quot;/dev/null&quot;, O_RDWR);</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也可以通过系统提供的库函数daemon实现注册守护进程。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int daemon(int nochdir, int noclose)；</span><br></pre></td></tr></table></figure><p>关闭守护进程时通过<strong>ps+grep</strong>找到对应的后台进程，使用kill命令将进程杀死。</p><h3 id="ps"><a href="#ps" class="headerlink" title="ps"></a><strong>ps</strong></h3><p>查看进程、进程组和会话之间的关系，默认情况下，ps只会列出与当前终端有关的进程信息</p><p>//显示与终端有关的进程信息 ps //按照UNIX Style显示全部进程信息,BSD 格式 ps aux //按照SYSTEM Style显示全部进程信息 ps -ef //根据条件过滤进程，查找想要的进程 ps aux | grep [条件] ps -ef | grep [条件] //动态查看进程 top //树形图的方式显示各进程之间的关系 pstree</p><h3 id="ping"><a href="#ping" class="headerlink" title="ping"></a><strong>ping</strong></h3><p>检查和监测网络，ping会向指定网址所在主机发送特殊的网络数据包ICMP_ECHO_REQUEST，大多数接收到包的设备会回复，进而检测网络连接</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//显示与终端有关的进程信息</span><br><span class="line">ps</span><br><span class="line">//按照UNIX Style显示全部进程信息,BSD 格式</span><br><span class="line">ps aux</span><br><span class="line">//按照SYSTEM Style显示全部进程信息</span><br><span class="line">ps -ef</span><br><span class="line">//根据条件过滤进程，查找想要的进程</span><br><span class="line">ps aux | grep [条件]</span><br><span class="line">ps -ef | grep [条件]</span><br><span class="line">//动态查看进程</span><br><span class="line">top</span><br><span class="line">//树形图的方式显示各进程之间的关系</span><br><span class="line">pstree</span><br></pre></td></tr></table></figure><h3 id="netstat"><a href="#netstat" class="headerlink" title="netstat"></a><strong>netstat</strong></h3><pre><code> 可以检查网络设置和统计数据。打印本地网卡全部连接、路由表信息、网卡接口信息。常用于现实TCP连接及其状态。更具体的路由表和网卡接口信息可以参考 route 和 ifconfig。</code></pre><blockquote><p>-n：使用IP地址表示主机，使用数字表示端口号；</p><p>-a：包含显示监听socket；</p><p>-t：仅显示TCP连接；</p><p>-r：显示路由信息；</p><p>-i：显示网卡接口的数据流量</p><p>-c：每隔1秒输出一次；</p><p>-o：显示socket定时器信息</p><p>-p：显示socket所属进程的PID和名字</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">//查看网络接口</span><br><span class="line">netstat -ie</span><br><span class="line"></span><br><span class="line">Kernel Interface table</span><br><span class="line">eth0      Link encap:Ethernet  HWaddr 00:16:3e:2e:fb:23  </span><br><span class="line">          inet addr:172.17.127.86  Bcast:172.17.127.255  Mask:255.255.240.0</span><br><span class="line">          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1</span><br><span class="line">          RX packets:4907900 errors:0 dropped:0 overruns:0 frame:0</span><br><span class="line">          TX packets:3827115 errors:0 dropped:0 overruns:0 carrier:0</span><br><span class="line">          collisions:0 txqueuelen:1000 </span><br><span class="line">          RX bytes:804903156 (804.9 MB)  TX bytes:2747292091 (2.7 GB)</span><br><span class="line"></span><br><span class="line">lo        Link encap:Local Loopback  </span><br><span class="line">          inet addr:127.0.0.1  Mask:255.0.0.0</span><br><span class="line">          UP LOOPBACK RUNNING  MTU:65536  Metric:1</span><br><span class="line">          RX packets:22990617 errors:0 dropped:0 overruns:0 frame:0</span><br><span class="line">          TX packets:22990617 errors:0 dropped:0 overruns:0 carrier:0</span><br><span class="line">          collisions:0 txqueuelen:1 </span><br><span class="line">          RX bytes:1669295103 (1.6 GB)  TX bytes:1669295103 (1.6 GB)</span><br></pre></td></tr></table></figure><p>​      </p><p>​        其中eth0是以太网接口，lo是内部回环网络接口，这是一个虚拟接口。执行日常网络诊断时，要查看的重要信息是每个网络接口第四行开头出现的单词“UP”，说明这个网络接口已经生效，还要查看第二行中 inet addr 字段出现的有效 IP 地址。对于使用 DHCP（动态主机配置协议）的系统，在这个字段中的一个有效 IP 地址则证明了 DHCP工作正常。</p><p>​        IP 地址以零结尾是指网络，而不是独立主机，所以如果出现 192.168.1.0 这意味着局域网中的任何一台主机。Gateway 是网关名字或 IP 地址，用来连接当前的主机和目的地的网络。若这个字段显示一个星号，则表明不需要网关。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//-r 显示内核的网络路由表 </span><br><span class="line">netstat -r</span><br><span class="line"></span><br><span class="line">Kernel IP routing table</span><br><span class="line">Destination     Gateway         Genmask         Flags   MSS Window  irtt Iface</span><br><span class="line">default         172.17.127.253  0.0.0.0         UG        0 0          0 eth0</span><br><span class="line">172.17.112.0    *               255.255.240.0   U         0 0          0 eth0</span><br></pre></td></tr></table></figure><p>使用telnet发起连接请求以后，查看本地具体某端口的连接状态</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">root@iZ2zed3d8a5mhbo5gb2m7rZ:~# netstat -nat | grep 127.0.0.1:9007</span><br><span class="line">tcp        0      0 127.0.0.1:9007          127.0.0.1:42852         ESTABLISHED</span><br><span class="line">tcp        0      0 127.0.0.1:42852         127.0.0.1:9007          ESTABLISHED</span><br><span class="line">tcp        0      0 127.0.0.1:9007          127.0.0.1:42844         ESTABLISHED</span><br><span class="line">tcp        0      0 127.0.0.1:42844         127.0.0.1:9007          ESTABLISHED</span><br></pre></td></tr></table></figure><h3 id="vmstat"><a href="#vmstat" class="headerlink" title="vmstat"></a><strong>vmstat</strong></h3><p>​        显示系统内存使用情况。比如进程信息，内存使用，CPU使用率以及I/O使用。常用选项如下：</p><blockquote><p>-f：显示系统启动以来fork次数；</p><p>-s：显示内存统计信息以及系统活动数量（CPU上下文切换次数）</p><p>-S：使用指定单位显示，k，K，m，M分别代表1000，1024，100 0000和1048576字节。</p><p>delay：采样间隔</p><p>count：采样次数</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">root@iZ2zed3d8a5mhbo5gb2m7rZ:~# vmstat -S K</span><br><span class="line">//进程信息 。     内存信息 。         虚拟内存     I/O 。    系统信息      CPU信息</span><br><span class="line">procs -----------memory---------- ---swap-- -----io---- -system-- ------cpu-----</span><br><span class="line"> r  b   swpd   free   buff  cache   si   so    bi    bo   in   cs us sy id wa st</span><br><span class="line"> 3  0      0 531512 193368 874068    0    0     0     4    2    1  1  1 99  0  0</span><br></pre></td></tr></table></figure><p>系统信息中，in表示每秒发生的中断次数，cs表示上下文（进程）切换次数</p><p>CPU信息中，wa表示等待I/O事件的时间占用CPU总运行时间时间的比例</p><h3 id="ifstat"><a href="#ifstat" class="headerlink" title="ifstat"></a><strong>ifstat</strong></h3><p>网络流量监测。常用选项如下：</p><blockquote><p>-a：检测所有网卡接口</p><p>-i：指定要监测的网卡接口；</p><p>-t：每行输出信息前加上时间戳；</p><p>-b：以Kbit/s单位显示数据，而不是默认的KB/S；</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">root@iZ2zed3d8a5mhbo5gb2m7rZ:~# ifstat -a -b</span><br><span class="line">        lo                 eth0       </span><br><span class="line"> Kbps in  Kbps out   Kbps in  Kbps out</span><br><span class="line">    0.00      0.00      1.36     12.36</span><br><span class="line">    0.00      0.00      0.52      5.53</span><br><span class="line">    0.00      0.00      0.52      1.11</span><br><span class="line">    0.00      0.00      6.96     66.96</span><br></pre></td></tr></table></figure><h3 id="strace"><a href="#strace" class="headerlink" title="strace"></a><strong>strace</strong></h3><p>​    <strong>测试服务器性能</strong>。跟踪程序运行过程中的系统调用和接收到的信号，并将系统调用名、参数、返回值、信号输出到标准输出或指定文件。常用选项如下：</p><blockquote><p>-c：统计每个系统调用执行时间、执行次数、出错次数；</p><p>-f：跟踪fork生成的子进程；</p><p>-t：输出的信息前加上时间信息；</p><p>-e：指定表达式控制跟踪系统调用</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-e trace=[set/open/read/write/close/file/process/network/signal/ipc/set]</span><br></pre></td></tr></table></figure><p>-o：写入指定文件</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">root@iZ2zed3d8a5mhbo5gb2m7rZ:~# strace -p 18492 -t</span><br><span class="line">strace: Process 18492 attached</span><br><span class="line">&#x2F;&#x2F;检测到文件描述符15的可读事件，还可结合lsof确定是新连接请求还是读事件</span><br><span class="line">10:46:20 epoll_wait(14, [&#123;EPOLLIN, &#123;u32&#x3D;15, u64&#x3D;11442492921853509647&#125;&#125;], 10000, -1) &#x3D; 1</span><br><span class="line">10:46:20 recvfrom(15, &quot;\16&quot;, 1024, 0, NULL, NULL) &#x3D; 1</span><br><span class="line">10:46:20 alarm(5)                       &#x3D; 0</span><br><span class="line">10:46:20 epoll_wait(14, 0x7ffc9eca11cc, 10000, -1) &#x3D; -1 EINTR (Interrupted system call)</span><br><span class="line">10:46:25 --- SIGALRM &#123;si_signo&#x3D;SIGALRM, si_code&#x3D;SI_KERNEL&#125; ---</span><br><span class="line">10:46:25 sendto(16, &quot;\16&quot;, 1, 0, NULL, 0) &#x3D; 1</span><br><span class="line">10:46:25 rt_sigreturn(&#123;mask&#x3D;[]&#125;)        &#x3D; -1 EINTR (Interrupted system call)</span><br><span class="line">10:46:25 epoll_wait(14, [&#123;EPOLLIN, &#123;u32&#x3D;15, u64&#x3D;11442492921853509647&#125;&#125;], 10000, -1) &#x3D; 1</span><br><span class="line">10:46:25 recvfrom(15, &quot;\16&quot;, 1024, 0, NULL, NULL) &#x3D; 1</span><br><span class="line">10:46:25 alarm(5)                       &#x3D; 0</span><br><span class="line">10:46:25 epoll_wait(14, ^Cstrace: Process 18492 detached</span><br><span class="line"> &lt;detached ...&gt;</span><br><span class="line">root@iZ2zed3d8a5mhbo5gb2m7rZ:~# </span><br></pre></td></tr></table></figure><p><strong>strace命令可以清楚地显示每次系统调用发生的事件，具体参数和执行流程，相对于gdb调试更加方便。</strong></p><h3 id="nc"><a href="#nc" class="headerlink" title="nc"></a><strong>nc</strong></h3><p>​    <strong>快速构建网络连接</strong>。可以调试客户端程序，也可以让它以客户端方式运行向服务器发起连接并收发数据。nc</p><p>命令可以快速测试与查找服务器的错误。常用选项如下：</p><blockquote><p>-i：设置数据包传送间隔；</p><p>-l：以服务器方式运行，监听指定端口。默认以客户端方式运行；</p><p>-k：重复接受并处理连接，与-l连用；</p><p>-n：IP地址表示主机，数字表示端口号；</p><p>-p：客户端方式运行时强制使用指定端口号。</p><p>-s：设置本地发送数据包的IP地址；</p><p>-U：使用UNIX本地域协议通信；</p><p>-u：使用UDP协议，默认是TCP协议；</p><p>-x：指定目标代理服务器的IP地址和端口号；</p><p>-w：客户端指定时间内未监测到输入则退出；</p></blockquote><p>每次按回车键发送一行数据时，nc客户端都会给服务器额外发送一个<CR><LF></LF></CR></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">//连接服务器并发送数据</span><br><span class="line">nc -C 127.0.0.1 9007</span><br><span class="line"></span><br><span class="line">root@iZ2zed3d8a5mhbo5gb2m7rZ:~# nc -C 127.0.0.1 9007</span><br><span class="line">GET http://localhost:9007/0 HTTP/1.1</span><br><span class="line">Host: localhost</span><br><span class="line"></span><br><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Content-Length:724</span><br><span class="line">Connection:close</span><br><span class="line"></span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">    &lt;head&gt;</span><br><span class="line">        &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">        &lt;title&gt;Sign up&lt;/title&gt;</span><br><span class="line">    &lt;/head&gt;</span><br><span class="line">    &lt;body&gt;</span><br><span class="line">&lt;br/&gt;</span><br><span class="line">&lt;br/&gt;</span><br><span class="line">    &lt;div align=&quot;center&quot;&gt;&lt;font size=&quot;5&quot;&gt; &lt;strong&gt;注册&lt;/strong&gt;&lt;/font&gt;&lt;/div&gt;</span><br><span class="line">    &lt;br/&gt;</span><br><span class="line">        &lt;div class=&quot;login&quot;&gt;</span><br><span class="line">                &lt;form action=&quot;3CGISQL.cgi&quot; method=&quot;post&quot;&gt;</span><br><span class="line">                        &lt;div align=&quot;center&quot;&gt;&lt;input type=&quot;text&quot; name=&quot;user&quot; placeholder=&quot;用户名&quot; required=&quot;required&quot;&gt;&lt;/div&gt;&lt;br/&gt;</span><br><span class="line">                        &lt;div align=&quot;center&quot;&gt;&lt;input type=&quot;password&quot; name=&quot;password&quot; placeholder=&quot;用户密码&quot; required=&quot;required&quot;&gt;&lt;/div&gt;&lt;br/&gt;</span><br><span class="line">                        &lt;div align=&quot;center&quot;&gt;&lt;button type=&quot;submit&quot;&gt;注册&lt;/button&gt;&lt;/div&gt;</span><br><span class="line">                &lt;/form&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><h3 id="lsof"><a href="#lsof" class="headerlink" title="lsof"></a><strong>lsof</strong></h3><p>列出当前系统打开的所有文件描述符。常用选项：</p><blockquote><p>-i：显示socket文件描述符；</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;ipv4&#x2F;ipv6, 传输层协议，主机名，IP地址，服务名，端口 lsof -i [4&#x2F;6] [protocol][@hostname|ipaddr][:service|port]</span><br></pre></td></tr></table></figure><p>-u：显示指定用户启动的所有进程打开的所有文件描述符；</p><p>-c：显示指定命令打开的所有文件描述符；</p><p>-p：指定进程打开的所有文件描述符；</p><p>-t：仅显示打开目标文件描述符的进程PID；</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">root@iZ2zed3d8a5mhbo5gb2m7rZ:~# lsof -p 18492</span><br><span class="line">COMMAND   PID USER   FD      TYPE             DEVICE SIZE/OFF     NODE NAME</span><br><span class="line">server  18492 root  cwd       DIR              253,1     4096  1183487 /root/TinyServer/TinyWebServer</span><br><span class="line">server  18492 root  rtd       DIR              253,1     4096        2 /</span><br><span class="line">server  18492 root  txt       REG              253,1   443816  1183686 /root/TinyServer/TinyWebServer/server</span><br><span class="line">server  18492 root  mem       REG              253,1    47600   131637 /lib/x86_64-linux-gnu/libnss_files-2.23.so</span><br><span class="line">server  18492 root  mem       REG              253,1  1088952   131614 /lib/x86_64-linux-gnu/libm-2.23.so</span><br><span class="line">server  18492 root  mem       REG              253,1  2365984   131590 /lib/x86_64-linux-gnu/libcrypto.so.1.0.0</span><br><span class="line">server  18492 root  mem       REG              253,1   428384   131594 /lib/x86_64-linux-gnu/libssl.so.1.0.0</span><br><span class="line">server  18492 root  mem       REG              253,1   104864   136960 /lib/x86_64-linux-gnu/libz.so.1.2.8</span><br><span class="line">server  18492 root  mem       REG              253,1    14608   131587 /lib/x86_64-linux-gnu/libdl-2.23.so</span><br><span class="line">server  18492 root  mem       REG              253,1  1868984   131573 /lib/x86_64-linux-gnu/libc-2.23.so</span><br><span class="line">server  18492 root  mem       REG              253,1    89696   131599 /lib/x86_64-linux-gnu/libgcc_s.so.1</span><br><span class="line">server  18492 root  mem       REG              253,1  1566440   271500 /usr/lib/x86_64-linux-gnu/libstdc++.so.6.0.21</span><br><span class="line">server  18492 root  mem       REG              253,1  3872160   264207 /usr/lib/x86_64-linux-gnu/libmysqlclient.so.20.3.17</span><br><span class="line">server  18492 root  mem       REG              253,1   138696   131660 /lib/x86_64-linux-gnu/libpthread-2.23.so</span><br><span class="line">server  18492 root  mem       REG              253,1   162632   131549 /lib/x86_64-linux-gnu/ld-2.23.so</span><br><span class="line">server  18492 root    0u      CHR              136,0      0t0        3 /dev/pts/0</span><br><span class="line">server  18492 root    1u      CHR              136,0      0t0        3 /dev/pts/0</span><br><span class="line">server  18492 root    2u      CHR              136,0      0t0        3 /dev/pts/0</span><br><span class="line">server  18492 root    3u     unix 0xffff880058a14000      0t0 21188863 type=STREAM</span><br><span class="line">server  18492 root    4u     unix 0xffff880058a14800      0t0 21188865 type=STREAM</span><br><span class="line">server  18492 root    5u     unix 0xffff880058a15800      0t0 21188867 type=STREAM</span><br><span class="line">server  18492 root    6u     unix 0xffff880035100400      0t0 21188869 type=STREAM</span><br><span class="line">server  18492 root    7u     unix 0xffff88007c11e400      0t0 21188871 type=STREAM</span><br><span class="line">server  18492 root    8u     unix 0xffff88007b1fc800      0t0 21188873 type=STREAM</span><br><span class="line">server  18492 root    9u     unix 0xffff88007aaa6800      0t0 21188875 type=STREAM</span><br><span class="line">server  18492 root   10u     unix 0xffff88007c27dc00      0t0 21188877 type=STREAM</span><br><span class="line">server  18492 root   11u     unix 0xffff88007c27cc00      0t0 21188879 type=STREAM</span><br><span class="line">server  18492 root   12u     unix 0xffff88007c230c00      0t0 21188881 type=STREAM</span><br><span class="line">server  18492 root   13u     IPv4           21188883      0t0      TCP *:9007 (LISTEN)</span><br><span class="line">server  18492 root   14u  a_inode               0,11        0     6993 [eventpoll]</span><br><span class="line">server  18492 root   15u     unix 0xffff88007c16a800      0t0 21188884 type=STREAM</span><br><span class="line">server  18492 root   16u     unix 0xffff88007c16a400      0t0 21188885 type=STREAM</span><br><span class="line">server  18492 root   17u     IPv4           21189422      0t0      TCP localhost:9007-&gt;localhost:42844 (ESTABLISHED)</span><br><span class="line">server  18492 root   18u     IPv4           21189582      0t0      TCP localhost:9007-&gt;localhost:42852 (ESTABLISHED)</span><br></pre></td></tr></table></figure><h3 id="tcpdump"><a href="#tcpdump" class="headerlink" title="tcpdump"></a><strong>tcpdump</strong></h3><p>网络抓包工具。常用选项：</p><blockquote><p>-n：IP显示主机而不是主机名，数字表示端口号而不是服务名称；</p><p>-i：指定监听的网卡接口；</p><p>-v：输出更详细的信息；</p><p>-t：不打印时间戳；</p><p>-e：仅显示以太网帧头部信息；</p><p>-c：仅抓取指定数量的数据包；</p><p>-x：十六进制显示数据包内容；</p><p>-s：设置抓包时的抓取长度；</p><p>-S：以绝对值显示TCP报文段的序号；</p><p>-r：从文件读取数据包并显示；</p></blockquote><p>还可以根据表达式进一步过滤数据。具体操作包括：类型、方向、协议。</p><ol><li>类型：支持host，port，net，postrange，分别指定主机名，端口号，网络地址，端口范围</li><li>方向：src指定发送数据包的发送端，dst指定目的端。</li><li>协议：指定目标协议。比如ICMP协议</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">root@iZ2zed3d8a5mhbo5gb2m7rZ:~# tcpdump -c 1 -x dst port 9007</span><br><span class="line">tcpdump: verbose output suppressed, use -v or -vv for full protocol decode</span><br><span class="line">listening on eth0, link-type EN10MB (Ethernet), capture size 262144 bytes</span><br><span class="line"></span><br><span class="line">11:23:14.330200 IP 218.197.198.148.4999 &gt; iZ2zed3d8a5mhbo5gb2m7rZ.9007: Flags [S], seq 1426509253, win 65535, options [mss 1460,nop,wscale 6,nop,nop,TS val 1588671432 ecr 0,sackOK,eol], length 0</span><br><span class="line">    0x0000:  4514 0040 0000 4000 3506 78e2 dac5 c694</span><br><span class="line">    0x0010:  ac11 7f56 c34a 232f 5506 cdc5 0000 0000</span><br><span class="line">    0x0020:  b002 ffff ce7a 0000 0204 05b4 0103 0306</span><br><span class="line">    0x0030:  0101 080a 5eb1 33c8 0000 0000 0402 0000</span><br><span class="line">1 packet captured</span><br><span class="line">1 packet received by filter</span><br><span class="line">0 packets dropped by kernel</span><br></pre></td></tr></table></figure><h3 id="telnet"><a href="#telnet" class="headerlink" title="telnet"></a><strong>telnet</strong></h3><p><strong>远程终端登录协议</strong>。可以确定远程服务端口访问状态。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//telnet [参数] [主机]</span><br><span class="line">//telnet www.baidu.com</span><br><span class="line">root@iZ2zed3d8a5mhbo5gb2m7rZ:~# telnet 127.0.0.1 9007</span><br><span class="line">Trying 127.0.0.1...</span><br><span class="line">Connected to 127.0.0.1.</span><br><span class="line">Escape character is &#x27;^]&#x27;.</span><br><span class="line">^C</span><br><span class="line">Connection closed by foreign host.</span><br></pre></td></tr></table></figure><p>常见telnet连接失败原因：</p><ol><li>IP地址、网址或者端口输入错误；</li><li>远程服务器主机未开启相应端口服务；</li><li>服务器开启了防火墙，或者未打开该端口的访问权限；</li><li>输入网址后域名解析出现错误；</li><li>如果主机已经启动，可能路由设置存在问题；</li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;总结常用的Linux网络编程命令，助力调试和网络系统信息查看。&lt;/p&gt;</summary>
    
    
    
    <category term="Linux" scheme="https://wangyinfeng123.github.io/categories/Linux/"/>
    
    
  </entry>
  
  <entry>
    <title>bitset</title>
    <link href="https://wangyinfeng123.github.io/2020/08/17/bitset/"/>
    <id>https://wangyinfeng123.github.io/2020/08/17/bitset/</id>
    <published>2020-08-17T03:41:06.000Z</published>
    <updated>2020-08-18T02:35:51.508Z</updated>
    
    <content type="html"><![CDATA[<p>C++中的bitset原理、常用函数</p><a id="more"></a><h2 id="bitset"><a href="#bitset" class="headerlink" title="bitset"></a>bitset</h2><h3 id="简介："><a href="#简介：" class="headerlink" title="简介："></a>简介：</h3><p>​    bitset在C++标准库中定义，方便使用位运算并且可以处理超过最长整型类型大小的位集合。bitset类型不同对象的<strong>区别仅在其长度而不在其类型</strong>，bitset中以0位开始的二进制位是低阶位，以31位结束的位串是高阶位（假定长度32位），占用内存较小，每个位置仅占1bit。</p><h2 id="用法："><a href="#用法：" class="headerlink" title="用法："></a>用法：</h2><h5 id="使用bitset，首先需要包含头文件bitset，然后明确变量长度，可以根据字符串和整数初始化，整数会转化成对应的二进制，支持位运算。"><a href="#使用bitset，首先需要包含头文件bitset，然后明确变量长度，可以根据字符串和整数初始化，整数会转化成对应的二进制，支持位运算。" class="headerlink" title="使用bitset，首先需要包含头文件bitset，然后明确变量长度，可以根据字符串和整数初始化，整数会转化成对应的二进制，支持位运算。"></a><strong>使用bitset，首先需要包含头文件bitset，然后明确变量长度</strong>，可以根据字符串和整数初始化，整数会转化成对应的二进制，支持位运算。</h5><blockquote><p>使用整型值初始化bitset时，此值会被转化为unsigned long long并被当作位模式处理，如果bitset的位大小超过unsigned long long的二进制位数，剩余高位会置0，反之如果小于则只会使用给定值的低位，超出bitset大小的高位被丢弃。                                                                                                                    </p><p>​                                                                                                                                            —《C++ Primer》</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bitset&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">bitset</span>&lt;32&gt; <span class="title">bisec1</span><span class="params">(<span class="number">0xffffffffffffffff</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="built_in">bitset</span>&lt;32&gt; <span class="title">bisec2</span><span class="params">(<span class="number">0xfff</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="built_in">bitset</span>&lt;32&gt; <span class="title">bisec3</span><span class="params">(<span class="string">&quot;00001&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;bisec1大小：&quot;</span> &lt;&lt; <span class="keyword">sizeof</span>(bisec1) &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; bisec1 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;bisec2大小：&quot;</span> &lt;&lt; <span class="keyword">sizeof</span>(bisec2) &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; bisec2 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;bisec3大小：&quot;</span> &lt;&lt; <span class="keyword">sizeof</span>(bisec3) &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; bisec3 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; (bisec1 &amp; bisec2) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">bisec1大小：<span class="number">8</span> <span class="number">11111111111111111111111111111111</span></span><br><span class="line">bisec2大小：<span class="number">8</span> <span class="number">00000000000000000000111111111111</span></span><br><span class="line">bisec3大小：<span class="number">8</span> <span class="number">00000000000000000000000000000001</span></span><br><span class="line"><span class="number">00000000000000000000111111111111</span></span><br><span class="line">[Finished in <span class="number">1.0</span>s]</span><br></pre></td></tr></table></figure><h3 id="接口函数"><a href="#接口函数" class="headerlink" title="接口函数"></a>接口函数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//对于一个叫做bit的bitset：</span></span><br><span class="line"><span class="built_in">bit</span>[pos]                    <span class="comment">//访问bit下标pos的位</span></span><br><span class="line"><span class="built_in">bit</span>.<span class="built_in">size</span>()           <span class="comment">//返回大小（位数）</span></span><br><span class="line"><span class="built_in">bit</span>.count()         <span class="comment">//返回1的个数</span></span><br><span class="line"><span class="built_in">bit</span>.any()           <span class="comment">//返回是否有1</span></span><br><span class="line"><span class="built_in">bit</span>.none()          <span class="comment">//返回是否没有1</span></span><br><span class="line"><span class="built_in">bit</span>.<span class="built_in">set</span>()           <span class="comment">//全都变成1</span></span><br><span class="line"><span class="built_in">bit</span>.<span class="built_in">set</span>(p)          <span class="comment">//将第p + 1位变成1（bitset是从第0位开始的！） </span></span><br><span class="line"><span class="built_in">bit</span>.<span class="built_in">set</span>(p, x)       <span class="comment">//将第p + 1位变成x</span></span><br><span class="line"><span class="built_in">bit</span>.reset()         <span class="comment">//全都变成0</span></span><br><span class="line"><span class="built_in">bit</span>.reset(p)        <span class="comment">//将第p + 1位变成0</span></span><br><span class="line"><span class="built_in">bit</span>.flip()          <span class="comment">//全都取反</span></span><br><span class="line"><span class="built_in">bit</span>.flip(p)         <span class="comment">//将第p + 1位取反</span></span><br><span class="line"><span class="built_in">bit</span>.to_ulong()      <span class="comment">//返回它转换为unsigned long的结果，如果超出范围则报错</span></span><br><span class="line"><span class="built_in">bit</span>.to_ullong()     <span class="comment">//返回它转换为unsigned long long的结果，如果超出范围则报错</span></span><br><span class="line"><span class="built_in">bit</span>.to_string()     <span class="comment">//返回它转换为string的结果</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;C++中的bitset原理、常用函数&lt;/p&gt;</summary>
    
    
    
    <category term="C++" scheme="https://wangyinfeng123.github.io/categories/C/"/>
    
    
    <category term="C++" scheme="https://wangyinfeng123.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>一致哈希</title>
    <link href="https://wangyinfeng123.github.io/2020/08/17/%E4%B8%80%E8%87%B4%E5%93%88%E5%B8%8C/"/>
    <id>https://wangyinfeng123.github.io/2020/08/17/%E4%B8%80%E8%87%B4%E5%93%88%E5%B8%8C/</id>
    <published>2020-08-17T01:42:07.000Z</published>
    <updated>2020-08-17T01:48:04.436Z</updated>
    
    <content type="html"><![CDATA[<p>总结一致哈希原理、问题以及解决方案</p><a id="more"></a><h2 id="一致哈希"><a href="#一致哈希" class="headerlink" title="一致哈希"></a>一致哈希</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>普通取模哈希算法的改良版，哈希函数计算方法不变，只不过是通过构建环状的 Hash 空间代替普通的线性 Hash 空间。</p><img src="/2020/08/17/%E4%B8%80%E8%87%B4%E5%93%88%E5%B8%8C/一致哈希.png" alt="一致哈希" style="zoom:50%;"><p>首先，选择一个足够大的Hash空间（一般是0undefined）构成一个哈希环。<br>对于缓存集群内的每个存储服务器节点计算 Hash 值，可以用服务器的 IP 或 主机名计算得到哈希值，计算得到的哈希值就是服务节点在 Hash 环上的位置。<br>最后，对每个需要存储的数据 key 同样也计算一次哈希值，计算之后的哈希也映射到环上，数据存储的位置是沿顺时针的方向找到的环上的第一个节点</p><h3 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h3><p>** 扩展能力提升 **<br>    普通哈希算法当需要扩容增加服务节点的时候，会导致原油哈希映射大面积失效；<br>    当缓存服务集群要新增一个节点node3时，受影响的只有 key3 对应的数据 value3，此时只需把 value3 由原来的节点 node0 迁移到新增节点 node3 即可，其余节点存储的数据保持不动</p><p>** 容错能力提升 **<br>    普通哈希算法当某一服务节点宕机下线，也会导致原来哈希映射的大面积失效，失效的映射触发数据迁移影响缓存服务性能，容错能力不足。<br>    假设 node2 节点宕机下线，则原来存储于 node2 的数据 value2 和 value5 ，只需按顺时针方向选择新的存储节点 node0 存放即可，不会对其他节点数据产生影响。一致性哈希能把节点宕机造成的影响控制在顺时针相邻节点之间，避免对整个集群造成影响。</p><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>** 数据倾斜 节点雪崩 **<br>    数据倾斜和节点宕机都可能会导致缓存雪崩，负载大的节点可能死机，导致大片缓存失效；</p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>** 虚拟节点 **<br>    对原来单一的物理节点在哈希环上虚拟出几个它的分身节点，这些分身节点称为虚拟节点。打到分身节点上的数据实际上也是映射到分身对应的物理节点上，这样一个物理节点可以通过虚拟节点的方式均匀分散在哈希环的各个部分，解决了数据倾斜问题。<br>    由于虚拟节点分散在哈希环各个部分，当某个节点宕机下线，他所存储的数据会被均匀分配给其他各个节点，避免对单一节点突发压力导致的节点雪崩问题。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;总结一致哈希原理、问题以及解决方案&lt;/p&gt;</summary>
    
    
    
    <category term="服务器" scheme="https://wangyinfeng123.github.io/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
    
    <category term="服务器" scheme="https://wangyinfeng123.github.io/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>布隆过滤器</title>
    <link href="https://wangyinfeng123.github.io/2020/08/17/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/"/>
    <id>https://wangyinfeng123.github.io/2020/08/17/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/</id>
    <published>2020-08-17T01:29:39.000Z</published>
    <updated>2020-08-17T01:38:36.141Z</updated>
    
    <content type="html"><![CDATA[<p>简要介绍布隆过滤器定义、应用场景及优缺点。</p><a id="more"></a><p><strong>简介：</strong></p><p> 布隆过滤器包含一个很长的二进制向量和一系列随机映射函数，<strong>可以检索一个元素是否在一个集合中</strong>。<strong>它的优点是空间效率和查询时间都比一般的算法要好的多，缺点是有一定的误识别率和删除困难</strong></p><p>布隆过滤器可以检查值是 <strong>“可能在集合中”</strong> 还是 <strong>“绝对不在集合中”</strong>。“可能” 表示有一定的概率，也就是说可能存在一定为误判率。</p><p><strong>使用：</strong></p><img src="/2020/08/17/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/截屏2020-08-1709.36.49.png" alt="截屏2020-08-1709.36.49" style="zoom:50%;"><ol><li>布隆过滤器本质上是由长度为 m 的位向量或位列表（仅包含 0 或 1 位值的列表）组成，最初所有的值均设置为 0；</li><li>将数据项添加到布隆过滤器中，我们会提供 K 个不同的哈希函数，并将该数据哈希之后的结果位置上k个对应索引位的值置为 “1”。</li><li>当对值进行搜索时，与哈希表类似，我们将使用 K 个哈希函数对 ”搜索的值“ 进行哈希运算，并查看其生成的索引值；</li><li>相应的索引位都被置为 1，这意味着我们可以说 ”fullstack“ 可能已经插入到集合中。事实上这可能出现误判，原因是由于哈希冲突导致的巧合而将不同的元素存储在相同的比特位上。</li><li><strong>搜索一个值的时候，若该值经过 K 个哈希函数运算后的任何一个索引位为 ”0“，那么该值肯定不在集合中。但如果所有哈希索引值均为 ”1“，则只能说该搜索的值可能存在集合中。</strong></li></ol><p><strong>应用场景：</strong></p><ul><li>网页爬虫对 URL 去重，避免爬取相同的 URL 地址；</li><li>反垃圾邮件，从数十亿个垃圾邮件列表中判断某邮箱是否垃圾邮箱；</li><li>Google Chrome 使用布隆过滤器识别恶意 URL；</li><li>Medium 使用布隆过滤器避免推荐给用户已经读过的文章；</li><li>Google BigTable，Apache HBbase 和 Apache Cassandra 使用布隆过滤器减少对不存在的行和列的查找。 除了上述的应用场景之外，布隆过滤器还有一个应用场景就是<strong>解决缓存穿透的问题</strong>。所谓的缓存穿透就是服务调用方<strong>每次都是查询不在缓存中的数据</strong>，这样每次服务调用都会到数据库中进行查询，如果这类请求比较多的话，就会导致数据库压力增大，这样缓存就失去了意义。</li></ul><p>​      可以预先把数据查询的主键，比如用户 ID 或文章 ID 缓存到过滤器中。当<strong>根据 ID 进行数据查询的时候，我们先判断该 ID 是否存在，若存在的话，则进行下一步处理</strong>。若不存在的话，直接返回，这样就不会触发后续的数据库查询。需要注意的是<strong>缓存穿透不能完全解决，我们只能将其控制在一个可以容忍的范围内</strong>。</p><p><strong>优点：</strong></p><p><strong>时间复杂度</strong></p><ul><li>添加元素时，由于<strong>不需要迭代位数组，而是简单的设置索引位的值</strong>，所以操作所花费的时间仅取决于散列函数的个数，所以对于对于k个哈希函数的布隆过滤器，添加元素的时间复杂度为O(k) 。</li><li>查询元素时，<strong>对于k个哈希函数的布隆过滤器，只需要在位数组中检查的索引数量有一个不变的上界</strong>，所以查询元素的时间复杂度也为O(k)。</li></ul><p><strong>空间复杂度</strong></p><p>​    由于<strong>不需要存储元素，只需依赖一定长度的位数组判断是否存在</strong>，并且<strong>数组长度的大小不取决于集合中元素的多少，可以在误判率变大或效率变低的代价下减少存储（位数组）</strong>。</p><p><strong>缺点：</strong></p><p>有一定的误判率，随着存入集合的元素的增加，误判率也随之增加。<strong>误判率大小和三个指标有关：位数组长度m、集合长度n、散列函数个数k</strong>。</p><p>删除困难，当删除一个元素时，因为哈希冲突的问题，<strong>可能会误删具有相同索引位的其他元素</strong>，所以删除时不需要（不容易）对位数组进行处理。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;简要介绍布隆过滤器定义、应用场景及优缺点。&lt;/p&gt;</summary>
    
    
    
    <category term="服务器" scheme="https://wangyinfeng123.github.io/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
    
    <category term="布隆过滤器" scheme="https://wangyinfeng123.github.io/tags/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/"/>
    
    <category term="大数据" scheme="https://wangyinfeng123.github.io/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
  </entry>
  
  <entry>
    <title>网络编程</title>
    <link href="https://wangyinfeng123.github.io/2020/08/13/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    <id>https://wangyinfeng123.github.io/2020/08/13/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/</id>
    <published>2020-08-13T06:20:45.213Z</published>
    <updated>2020-08-14T01:28:59.166Z</updated>
    
    <content type="html"><![CDATA[<p>简要介绍Select、Poll、Epoll之间的区别</p><a id="more"></a><h2 id="相同点"><a href="#相同点" class="headerlink" title="相同点"></a>相同点</h2><h3 id="同步非阻塞"><a href="#同步非阻塞" class="headerlink" title="同步非阻塞"></a>同步非阻塞</h3><pre><code>都属于同步非阻塞IO复用，都可以同时监听多个文件描述符，等待由timeout参数指定的超时时间，直到文件描述符有就绪事件发生时，返回就绪的文件描述符数量；</code></pre><h3 id="内核交互"><a href="#内核交互" class="headerlink" title="内核交互"></a>内核交互</h3><pre><code>都是通过某种结构体变量告诉内核监听哪些文件描述符上的哪些事件，并使用该结构体类型的参数获取内核处理结果。</code></pre><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select:read_set,write_set,error_set</span><br><span class="line">poll:pollfd_set</span><br><span class="line">epoll:epoll_event</span><br></pre></td></tr></table></figure><h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><ol><li>select的文件描述符集fd_set仅仅是文件描述符集合，<strong>没有将文件描述符和事件绑定</strong>，所以select需要向内核传入3个这种类型的参数分别处理可读、可写、异常事件；另外内核每次会在线修改fd_set，因此<strong>程序下次调用select前还需要重置fd_set</strong>；</li><li>poll的参数类型pollfd把事件和文件描述符都定义在里面，<strong>只需要一个事件集参数</strong>，编程接口更加简洁；而且内核每次修改的是revents成员，没有改变events成员，因此<strong>下次调用poll时程序不需要重置pollfd</strong>；</li><li>epoll是一组系统调用，具体有epoll_create，epoll_ctl和epoll_wait，它<strong>在内核中维护一个事件表</strong>，通过epoll_ctl来添加、删除和修改事件，每次调用epoll_wait直接从内核取得注册的事件信息，<strong>不需要反复从用户空间将事件读入内核</strong>；</li><li><strong>select和poll每次返回的是用户注册的所有事件集合，</strong>包含就绪和未就绪事件，并且通过轮询的方式遍历整个文件描述符集合，导致<strong>程序索引就绪文件描述符的时间为O(n)**；epoll是通过回调的方式，内核检测到就绪事件触发回调函数，回调函数将该文件描述符插入内核就绪事件队列，由内核在适当时机将就绪事件队列内容拷贝到用户空间，</strong>epoll_wait返回的是就绪的事件个数<strong>，</strong>程序索引就绪文件描述符的时间为O(1)；**</li><li>poll和epoll<strong>最多监听的文件描述符个数都能达到系统允许的最大数目</strong>65535，而<strong>select通常有限制；</strong></li><li><strong>select和poll只能工作在水平触发LT模式</strong>，<strong>epoll可以工作在边缘出发ET模式</strong>，并且可以通过EPOLLONESHOT属性进一步减少可读可写异常的事件触发次数；</li></ol><h2 id="大小端字节序"><a href="#大小端字节序" class="headerlink" title="大小端字节序"></a>大小端字节序</h2><h3 id="大端字节序"><a href="#大端字节序" class="headerlink" title="大端字节序"></a>大端字节序</h3><p>又称网络字节序，数据的高位字节存放在内存的低地址处，低位字节存放在内存的高地址处；</p><h3 id="小端字节序"><a href="#小端字节序" class="headerlink" title="小端字节序"></a>小端字节序</h3><p>又称主机字节序，数据的高位字节存放在内存的高地址处，低位字节存放在内存的低地址处；</p><h2 id="短连接与长连接"><a href="#短连接与长连接" class="headerlink" title="短连接与长连接"></a>短连接与长连接</h2><h3 id="短连接"><a href="#短连接" class="headerlink" title="短连接"></a>短连接</h3><pre><code>服务端在处理完客户端的一个http请求以后主动关闭TCP连接，此后，客户端如果再发送http请求需要重新建立新的TCP连接，也就是说，**同一个客户的多个http请求不能共用同一个TCP连接</code></pre><h3 id="长连接"><a href="#长连接" class="headerlink" title="长连接"></a>长连接</h3><pre><code>同一个客户的多个http请求可以共用同一个TCP连接，**即客户端在fasonghttp请求之后，再次发起http请求不需要重新建立新的TCP连接；</code></pre><p>长连接的优势：<strong>极大减少网络建立TCP连接导致的负荷，同时缩短了每次请求的时间延迟</strong>。http请求和回答报文中的connection字段对应的closed与keep-alive分别对应短连接与长连接</p><h2 id="I-O设计中reactor和proactor模式的区别"><a href="#I-O设计中reactor和proactor模式的区别" class="headerlink" title="I/O设计中reactor和proactor模式的区别"></a>I/O设计中reactor和proactor模式的区别</h2><ul><li>1、 Reactor被动的等待指示事件的到来并作出反应，有一个等待的过程，做什么都要先放入到监听事件集合中等待handler可用时再进行操作，实现相对简单，对于耗时短的处理场景比较高效，但Reactor处理耗时长的操作会造成事件分发的阻塞，影响到后续事件的处理。 </li><li>Proactor直接调用异步读写操作，调用完后立刻返回，实现了一个主动的事件分离和分发模型；这种设计允许多个任务并发的执行，从而提高吞吐量；并可执行耗时长的任务（各个任务间互不影响），Proactor性能更高，能够处理耗时长的并发场景，但Proactor实现逻辑复杂；依赖操作系统对异步的支持，目前实现了纯异步操作的操作系统少，实现优秀的如windows IOCP，但由于其windows系统用于服务器的局限性，目前应用范围较小；而Unix/Linux系统对纯异步的支持有限，应用事件驱动的主流还是通过select/epoll来实现。</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;简要介绍Select、Poll、Epoll之间的区别&lt;/p&gt;</summary>
    
    
    
    <category term="Linux" scheme="https://wangyinfeng123.github.io/categories/Linux/"/>
    
    <category term="网络编程" scheme="https://wangyinfeng123.github.io/categories/Linux/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="Linux" scheme="https://wangyinfeng123.github.io/tags/Linux/"/>
    
    <category term="网络编程" scheme="https://wangyinfeng123.github.io/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://wangyinfeng123.github.io/2020/08/12/hello-world/"/>
    <id>https://wangyinfeng123.github.io/2020/08/12/hello-world/</id>
    <published>2020-08-12T13:22:22.134Z</published>
    <updated>2020-08-13T13:18:42.833Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><a id="more"></a><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for more info. If you get any problems when using Hexo, you can find the answer in &lt;a href=&quot;https://hexo.io/docs/troubleshooting.html&quot;&gt;troubleshooting&lt;/a&gt; or you can ask me on &lt;a href=&quot;https://github.com/hexojs/hexo/issues&quot;&gt;GitHub&lt;/a&gt;.&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
</feed>
