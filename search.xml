<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title></title>
    <url>/2020/08/13/tupian/</url>
    <content><![CDATA[<hr>
<p>tupian</p>
<hr>
<p><img src="/Users/wangyinfeng/Downloads/BlogLogo.jpeg" alt="BlogLogo"></p>
]]></content>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2020/08/12/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>网络编程</title>
    <url>/2020/08/13/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<p>简要介绍Select、Poll、Epoll之间的区别</p>
<h2 id="相同点"><a href="#相同点" class="headerlink" title="相同点"></a>相同点</h2><h3 id="同步非阻塞"><a href="#同步非阻塞" class="headerlink" title="同步非阻塞"></a>同步非阻塞</h3><pre><code>都属于同步非阻塞IO复用，都可以同时监听多个文件描述符，等待由timeout参数指定的超时时间，直到文件描述符有就绪事件发生时，返回就绪的文件描述符数量；</code></pre>
<h3 id="内核交互"><a href="#内核交互" class="headerlink" title="内核交互"></a>内核交互</h3><pre><code>都是通过某种结构体变量告诉内核监听哪些文件描述符上的哪些事件，并使用该结构体类型的参数获取内核处理结果。</code></pre>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">select:read_set,write_set,error_set</span><br><span class="line">poll:pollfd_set</span><br><span class="line">epoll:epoll_event</span><br></pre></td></tr></table></figure>

<h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><ol>
<li>select的文件描述符集fd_set仅仅是文件描述符集合，<strong>没有将文件描述符和事件绑定</strong>，所以select需要向内核传入3个这种类型的参数分别处理可读、可写、异常事件；另外内核每次会在线修改fd_set，因此<strong>程序下次调用select前还需要重置fd_set</strong>；</li>
<li>poll的参数类型pollfd把事件和文件描述符都定义在里面，<strong>只需要一个事件集参数</strong>，编程接口更加简洁；而且内核每次修改的是revents成员，没有改变events成员，因此<strong>下次调用poll时程序不需要重置pollfd</strong>；</li>
<li>epoll是一组系统调用，具体有epoll_create，epoll_ctl和epoll_wait，它<strong>在内核中维护一个事件表</strong>，通过epoll_ctl来添加、删除和修改事件，每次调用epoll_wait直接从内核取得注册的事件信息，<strong>不需要反复从用户空间将事件读入内核</strong>；</li>
<li><strong>select和poll每次返回的是用户注册的所有事件集合，</strong>包含就绪和未就绪事件，并且通过轮询的方式遍历整个文件描述符集合，导致<strong>程序索引就绪文件描述符的时间为O(n)**；epoll是通过回调的方式，内核检测到就绪事件触发回调函数，回调函数将该文件描述符插入内核就绪事件队列，由内核在适当时机将就绪事件队列内容拷贝到用户空间，</strong>epoll_wait返回的是就绪的事件个数<strong>，</strong>程序索引就绪文件描述符的时间为O(1)；**</li>
<li>poll和epoll<strong>最多监听的文件描述符个数都能达到系统允许的最大数目</strong>65535，而<strong>select通常有限制；</strong></li>
<li><strong>select和poll只能工作在水平触发LT模式</strong>，<strong>epoll可以工作在边缘出发ET模式</strong>，并且可以通过EPOLLONESHOT属性进一步减少可读可写异常的事件触发次数；</li>
</ol>
<h2 id="大小端字节序"><a href="#大小端字节序" class="headerlink" title="大小端字节序"></a>大小端字节序</h2><h3 id="大端字节序"><a href="#大端字节序" class="headerlink" title="大端字节序"></a>大端字节序</h3><p>又称网络字节序，数据的高位字节存放在内存的低地址处，低位字节存放在内存的高地址处；</p>
<h3 id="小端字节序"><a href="#小端字节序" class="headerlink" title="小端字节序"></a>小端字节序</h3><p>又称主机字节序，数据的高位字节存放在内存的高地址处，低位字节存放在内存的低地址处；</p>
<h2 id="短连接与长连接"><a href="#短连接与长连接" class="headerlink" title="短连接与长连接"></a>短连接与长连接</h2><h3 id="短连接"><a href="#短连接" class="headerlink" title="短连接"></a>短连接</h3><pre><code>服务端在处理完客户端的一个http请求以后主动关闭TCP连接，此后，客户端如果再发送http请求需要重新建立新的TCP连接，也就是说，**同一个客户的多个http请求不能共用同一个TCP连接</code></pre>
<h3 id="长连接"><a href="#长连接" class="headerlink" title="长连接"></a>长连接</h3><pre><code>同一个客户的多个http请求可以共用同一个TCP连接，**即客户端在fasonghttp请求之后，再次发起http请求不需要重新建立新的TCP连接；</code></pre>
<p>长连接的优势：<strong>极大减少网络建立TCP连接导致的负荷，同时缩短了每次请求的时间延迟</strong>。http请求和回答报文中的connection字段对应的closed与keep-alive分别对应短连接与长连接</p>
<h2 id="I-O设计中reactor和proactor模式的区别"><a href="#I-O设计中reactor和proactor模式的区别" class="headerlink" title="I/O设计中reactor和proactor模式的区别"></a>I/O设计中reactor和proactor模式的区别</h2><ul>
<li>1、 Reactor被动的等待指示事件的到来并作出反应，有一个等待的过程，做什么都要先放入到监听事件集合中等待handler可用时再进行操作，实现相对简单，对于耗时短的处理场景比较高效，但Reactor处理耗时长的操作会造成事件分发的阻塞，影响到后续事件的处理。 </li>
<li>Proactor直接调用异步读写操作，调用完后立刻返回，实现了一个主动的事件分离和分发模型；这种设计允许多个任务并发的执行，从而提高吞吐量；并可执行耗时长的任务（各个任务间互不影响），Proactor性能更高，能够处理耗时长的并发场景，但Proactor实现逻辑复杂；依赖操作系统对异步的支持，目前实现了纯异步操作的操作系统少，实现优秀的如windows IOCP，但由于其windows系统用于服务器的局限性，目前应用范围较小；而Unix/Linux系统对纯异步的支持有限，应用事件驱动的主流还是通过select/epoll来实现。</li>
</ul>
]]></content>
      <tags>
        <tag>Linux</tag>
        <tag>网络编程</tag>
      </tags>
  </entry>
</search>
